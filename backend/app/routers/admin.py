"""
API router for administrative tasks like generating voice samples.
"""

import os
import wave
import logging
from pathlib import Path
from fastapi import APIRouter, HTTPException, BackgroundTasks
from pydantic import BaseModel

from backend.app.services.engine import engine, PERSONAPLEX_VOICES

logger = logging.getLogger("PersonaPlex-Admin")

router = APIRouter(prefix="/api/admin", tags=["admin"])

# Output directory for voice samples
SAMPLES_DIR = Path(__file__).parent.parent.parent.parent / "public" / "voice-samples"

class GenerateSamplesResponse(BaseModel):
    status: str
    message: str
    voices_generated: list[str] = []


def save_audio_to_wav(audio_bytes: bytes, output_path: Path, sample_rate: int = 24000):
    """Save raw float32 audio bytes to a WAV file."""
    import numpy as np
    
    # Convert bytes to float32 numpy array
    audio_np = np.frombuffer(audio_bytes, dtype=np.float32)
    
    # Convert to int16 for WAV
    audio_int16 = (audio_np * 32767).astype(np.int16)
    
    # Write WAV file
    with wave.open(str(output_path), 'w') as wav_file:
        wav_file.setnchannels(1)
        wav_file.setsampwidth(2)  # 16-bit
        wav_file.setframerate(sample_rate)
        wav_file.writeframes(audio_int16.tobytes())


@router.post("/generate-voice-samples", response_model=GenerateSamplesResponse)
async def generate_voice_samples():
    """
    Generate voice preview samples for all PersonaPlex voices.
    This is an admin endpoint that should be run once to create static samples.
    
    The samples are generated by having the AI speak a greeting phrase
    with each voice profile.
    """
    if engine.is_mock:
        raise HTTPException(
            status_code=503,
            detail="PersonaPlex engine not loaded. Cannot generate real voice samples."
        )
    
    if engine.wrapper is None:
        raise HTTPException(
            status_code=503,
            detail="PersonaPlex wrapper not initialized."
        )
    
    # Ensure output directory exists
    SAMPLES_DIR.mkdir(parents=True, exist_ok=True)
    
    generated = []
    errors = []
    
    # Sample greeting - short and clear
    # We'll generate by simulating a conversation start
    
    for voice_id in PERSONAPLEX_VOICES:
        try:
            logger.info(f"Generating sample for voice: {voice_id}")
            
            # Reset engine state
            engine.reset()
            
            # Configure with this voice - try to get exact phrase
            engine.configure(
                persona="You are demonstrating your voice. When asked, repeat EXACTLY: 'The quick brown fox jumps over the lazy dog.' Say nothing else, just that sentence.",
                voice_id=voice_id
            )
            
            # Generate ~3 seconds of audio by processing silence
            # This prompts the AI to speak its greeting
            import numpy as np
            
            sample_rate = 24000
            duration = 3.0  # seconds
            chunk_size = 1920
            
            # Feed silence to prompt the AI to speak
            silence = np.zeros(int(sample_rate * duration), dtype=np.float32)
            
            output_audio = b""
            for i in range(0, len(silence), chunk_size):
                chunk = silence[i:i+chunk_size]
                if len(chunk) < chunk_size:
                    chunk = np.pad(chunk, (0, chunk_size - len(chunk)))
                
                result = engine.process_audio_frame(chunk.tobytes())
                if result:
                    output_audio += result
            
            if len(output_audio) > 0:
                output_path = SAMPLES_DIR / f"{voice_id}.wav"
                save_audio_to_wav(output_audio, output_path, sample_rate)
                generated.append(voice_id)
                logger.info(f"✓ Generated: {output_path}")
            else:
                errors.append(f"{voice_id}: No audio generated")
                logger.warning(f"✗ No audio for {voice_id}")
                
        except Exception as e:
            errors.append(f"{voice_id}: {str(e)}")
            logger.error(f"Error generating {voice_id}: {e}")
    
    # Reset engine after all generation
    engine.reset()
    
    if errors:
        return GenerateSamplesResponse(
            status="partial",
            message=f"Generated {len(generated)}/{len(PERSONAPLEX_VOICES)} samples. Errors: {errors}",
            voices_generated=generated
        )
    
    return GenerateSamplesResponse(
        status="success",
        message=f"Generated all {len(generated)} voice samples!",
        voices_generated=generated
    )


@router.get("/health")
async def health_check():
    """Check if the engine is loaded and ready."""
    return {
        "status": "ok",
        "engine_loaded": not engine.is_mock,
        "wrapper_ready": engine.wrapper is not None
    }
